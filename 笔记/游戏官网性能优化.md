## 常见的性能优化
+ 图片压缩
+ cdn资源
+ 代码压缩
+ 按需加载(这次的重点)

### 先来分析下

1. 项目中慢的原因是什么？

+ webpack打包会将所有代码打包到一个`bundle`，然而随着项目额逐渐扩大，文件数量将急剧增加，不经意间使得打包文件过大而造成应用加载的缓慢。

2. 解决的目标是什么？

+ 能否`按需加载`

3. 采用的办法是什么？

+ `Code Splitting`（提倡的是将代码分块`chunk`，通过定义一些`分割点`来实现分块，从而实现按需加载。）

### 思考的过程中产生的几点疑问

```
1. 分析产生`慢`的原因
2. 知道为什么`慢`，但是如何解决呢？
3. 知道了解决办法，可是为什么这么做就能实现按需加载呢？
```

### 带着以上的几点疑问，我想要更深入的了解以下几个点

```
1. ES6的import()函数为什么可以实现动态导入
2. ES6的模块加载机制
3. webpack模块化原理
<!-- 甚至还要了解更多相关的信息 -->
```

### 解决疑问

+ 主要参考的是es6官网、webpack官网、react官网等；
+ 针对上述的问题1，可以参考另一篇《ECMAScript 6 入门》学习笔记
  + 对比

  ||引擎处理时机|参数|加载方式|说明|
  |----|----|----|----|----|
  |import语句|编译时|模块位置|静态加载|利于编译器提高效率、但不能条件加载|
  |import()函数|运行时|模块位置|动态加载|可以运行时、条件加载|

  + import()返回一个 Promise 对象
  + import()函数可以用在任何地方，什么时候运行到这一句，就会加载指定的模块
  + 适用场合
    1. 按需加载。import()可以在需要的时候，再加载某个模块。
    2. 条件加载。import()可以放在if代码块，根据不同的情况，加载不同的模块。
    3. 动态的模块路径。import()允许模块路径动态生成。
+ 针对上述的问题2，可以参考另一篇《ECMAScript 6 入门》学习笔记
+ 问题3还在学习中[囧]


### 最后附上实现方案

+ 依赖的有react-router、webpack、ES6的import()、webpack打包分析插件webpack-bundle-analyzer等
+ Bundle.js
```
import React from 'react';

export default class Bundle extends React.Component {
    state = {
      mod: null
    }
    componentWillMount() {
      console.log("Bundle---,",this.props)
      this.load(this.props);
    }
    componentWillReceiveProps(nextProps) {
      if (nextProps.load !== this.props.load) {
        this.load(nextProps);
      }
    }
    // 更改 load 方法为异步函数
    async load(props) {
      this.setState({
        mod: null
      });
      /*
        使用 props.load() 返回的是一个 promise
        */
      const mod = await props.load();

      this.setState({
        mod: mod.default ? mod.default : mod
      });
    }

    render() {
      return this.state.mod ? this.props.children(this.state.mod) : null;
    }
}

```
+ lazyLoad.js

```
import React from 'react';
import Bundle from './Bundle';

// 默认加载组件，可以直接返回 null
const Loading = () => <div>Loading...</div>;

/*
    包装方法，第一次调用后会返回一个组件（函数式组件）
    由于要将其作为路由下的组件，所以需要将 props 传入
*/
const lazyLoad = loadComponent => props => (
  <Bundle load={loadComponent}>
    {Comp => (Comp ? <Comp {...props} /> : <Loading />)}
  </Bundle>
);

export default lazyLoad;

```
+ 使用router配置的入口文件

```
import React from 'react'
import { Route } from 'react-router-dom'
import lazyLoad from '../lazyLoad';
<!--静态加载方式-->
// import GameNetwork from '../containers/gameNetwork'
<!--动态加载方式-->
const GameNetwork = lazyLoad(() => import('../containers/gameNetwork'));
<!--N多其他路由定义-->

export default class Routes extends React.Component {
  render() {
    let routes = (
        <div className="view">
            <!--N多其他路由配置-->
            <Route path="/gameNetwork.html" component={GameNetwork}/>
        </div>
    )
    return routes
  }
}

```

+ webpack配置

```
<!-- 省略了详细配置 -->
module.exports = {
  entry: [
    './src/index.js'
  ],
  output: {
    path: resolve('output'),
    filename: 'js/[name].[chunkhash:5].js' ,
    publicPath: '',
    chunkFilename: 'js/[name].[chunkhash:5].chunk.js'
  },
}

module.exports.plugins.push(
    // webpack打包分析图、需要的时候可以打开注释
    new BundleAnalyzerPlugin({ analyzerPort: 8919 })
)
```


### 优化后的效果

+ 分包之前：main.js中包含的是所有的js文件、而优化后则只包含了当前路由需要的js文件、
+ 分包之后：main从原来的`一个1.8M`文件变成了`90多K的main和84k的chunk`

![优化前](https://raw.githubusercontent.com/liujinhuan/LearnNotes/master/imgs/%E4%BC%98%E5%8C%96%E5%89%8D.jpeg)
![优化后](https://raw.githubusercontent.com/liujinhuan/LearnNotes/master/imgs/%E4%BC%98%E5%8C%96%E5%90%8E.jpeg)

### 参考文件

[webpack代码分离](https://webpack.docschina.org/guides/code-splitting/)

[react code-splitting](https://www.reactjscn.com/docs/code-splitting.html)

[ES6 import()函数](http://es6.ruanyifeng.com/#docs/module#import)

[webpack 模块方法](https://webpack.docschina.org/api/module-methods/)

[有赞 webpack模块化原理-commonjs](https://segmentfault.com/a/1190000010349749)