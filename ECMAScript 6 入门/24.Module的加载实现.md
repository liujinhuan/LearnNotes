### 如何在浏览器和 Node 之中加载 ES6 模块

### 浏览器加载

+ 传统方法，通过html的`script`标签加载js脚本
+ 默认情况下，浏览器是`同步加载`脚本，即渲染引擎遇到`script`标签，就去执行js脚本，执行完之后，再渲染页面。如果是外部引入的脚本还要算上下载脚本的时间
+ 如果是体量较大的脚本，会造成浏览器的假死，所以浏览器允许`异步加载`脚本    
+ `<script>`标签打开defer或async属性，脚本就会异步加载。渲染引擎会先下载外部脚本，但不会等他下载和执行，就继续执行后面的命令了。

|defer|async|
|----|----|
|渲染完再执行，加载不阻塞，执行不阻塞|下载完就执行，加载不阻塞，执行会阻塞|
|多个会按照顺序加载|多个的话并不能保证加载顺序|


### 加载ES6模块规则

+ script添加`type="module"`属性，标致引用的脚本是es6模块

```
<script type="module" src="./foo.js"></script>
```

+ 如果有多个es6模块，会按顺序依次执行
+ 也可以添加`async`属性，但是就不会保证顺序了，而是会`加载完就执行`
+ 几点注意
    + 代码在模块作用域中运行，而不是全局作用域
    + 自动采用严格模式
    + 模块中可以import其他模块
    + 模块顶层this=undefined，可以用此来判断是不是在es6模块之中
    + 如果多次加载同一个模块，则只会执行一次

### es6模块和CommonJS模块的差异

|CommonJS模块|ES6模块|
|----|----|
|运行时加载|编译时加载|
|输出的是值的拷贝，会被缓存|输出的是值的引用，不会被缓存|
|模块是对象|模块不是对象，是一种静态定义|
|this指向当前模块|this=undefined|

### Node加载

+ Node本来是有自己的CommonJS模块格式的
+ 但是为了兼容ES6模块，目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。
+ Node 要求 ES6 模块采用.mjs后缀文件名
+ 目前，Node 的import命令只支持加载本地模块（file:协议），不支持加载远程模块。
+ Node 的import命令是异步加载，这一点与浏览器的处理方法相同
+ Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。

### ES6 模块加载 CommonJS 模块

+ CommonJS 模块的输出都定义在module.exports这个属性上面。
+ Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。

```
module.exports 等同于  export default 
```

### CommonJS 模块加载 ES6 模块 

+ CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。

### 循环加载CommonJS

+ “循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。
+ 目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。
+ CommonJS 模块的重要特性是`加载时执行`，即脚本代码`在require的时候，就会全部执行`。一旦出现`某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出`。

### 循环加载ES6

+ ES6 处理“循环加载”与 CommonJS 有本质的不同。
+ ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
+ 必要时可以使用`函数提升`


### ES6 模块的转码

+ 浏览器目前还不支持 ES6 模块
